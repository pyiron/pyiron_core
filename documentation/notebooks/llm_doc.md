## üéØ Goal  
Create a **Pyiron Workflow** that is **self‚Äëcontained**, **executable after copy‚Äëpaste**, and **easy to use**.  
The workflow should:

1. **Generate / transform** data.  
2. **Process** the data in one or more steps.  
3. **Plot / output** the results.  

All data should travel through **typed dataclass containers** (input‚Äë and output‚Äëdataclasses) to keep the graph tidy and to minimise the number of individual ports.  

---  

## üì¶ Allowed Imports  

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from pyiron_workflow import (
    Workflow,
    as_function_node,
    as_out_dataclass_node,
    as_inp_dataclass_node,
)
from pyiron_workflow.data_fields import DataArray, EmptyArrayField
from typing import Optional, Literal, TypeAlias, Protocol
# For atomistic use‚Äëcases:
from ase import Atoms
```

*Only the modules listed above may be imported.*  
If you need additional utilities, generate them **inside a node** (see Rule‚ÄØ5).  

---  

## üß© 1Ô∏è‚É£ Function‚ÄëNode Rules  

### 1.1‚ÄØAll arguments must have **type annotations**  

| Allowed types | Description |
|---------------|-------------|
| `int`, `float`, `bool`, `str` | Primitive literals. |
| `np.ndarray` | Numpy arrays. |
| `Atoms` | ASE atomic structures. |
| `Figure` | Matplotlib figure objects. |
| **Custom dataclasses** (see ¬ß‚ÄØ2) | Use the **decorated class name** (`Mesh2D`, `GridSpec`, ‚Ä¶) as the type hint. **Never** place a call (`()`) in the annotation. |
| `Optional[Literal["opt1","opt2",‚Ä¶]]` | Finite‚Äëchoice inputs, possibly optional. |
| `Literal["val1","val2",‚Ä¶]` | Mandatory finite‚Äëchoice inputs. |

> **Why the restriction?**  
> The workflow engine inspects signatures to generate node‚Äëoutput containers and to validate connections. Calls such as `Mesh2D().dataclass()` are *instances*, not *types*, and therefore illegal in a type hint.

### 1.2‚ÄØReturn‚Äëtype annotation must **match the actual returned object**  

* If a node returns a **custom dataclass**, annotate the return type with the **class name** (`-> Mesh2D`).  
* If a node returns a primitive or `np.ndarray`, annotate accordingly (`-> np.ndarray`).  

### 1.3‚ÄØExpose **all useful parameters** of the underlying function/code  

* Every parameter that a user might want to control should appear as a **node argument**.  
* For parameters that have a **finite set of valid values**, use `Optional[Literal[...]]` (or `Literal[...]` if mandatory).  
* Example (plotting colormap):  

  ```python
  CmapChoice = Optional[Literal["viridis", "plasma", "inferno", "magma", "cividis"]]
  def PlotDensity(rho: Mesh2D, cmap: CmapChoice = "viridis") -> Figure: ...
  ```

### 1.4‚ÄØPhysical constants must be **defined inside the node** that uses them.  

* Example (Boltzmann constant in eV/K):  

  ```python
  def ComputeDensity(...):
      kB_eV_per_K = 8.617333262e-5   # defined inside the node
      ...
  ```

### 1.5‚ÄØNode granularity ‚Äì **avoid over‚Äësplitting** related logic.  

A node should perform a **coherent computational step** (e.g., ‚Äúcreate potential‚Äù, ‚Äúcompute density‚Äù, ‚Äúplot result‚Äù).  

### 1.6‚ÄØ**No external file assumptions**  

* Do **not** read/write files unless the user explicitly requests a file‚Äëbased node.  

### 1.7‚ÄØ**No numeric indexing** of multi‚Äëoutput nodes (see ¬ß‚ÄØ3).  

---  

## üìä 2Ô∏è‚É£ Custom Dataclass Nodes (Input & Output)  

### 2.1‚ÄØDefinition  

```python
@as_out_dataclass_node
class Mesh2D:
    array: DataArray = EmptyArrayField   # 2‚ÄëD data array
    x:     DataArray = EmptyArrayField   # 1‚ÄëD x‚Äëcoordinates
    y:     DataArray = EmptyArrayField   # 1‚ÄëD y‚Äëcoordinates
```

```python
@as_inp_dataclass_node
class GridSpec:
    x_min: float = 0.0
    x_max: float = 2 * np.pi
    y_min: float = 0.0
    y_max: float = 2 * np.pi
    nx:    int   = 100
    ny:    int   = 100
```

*The decorator does **not** turn the class into a normal Python class; it creates a **factory function**.*  

### 2.2‚ÄØHow to use them in type hints  

| Situation | Correct syntax | Reason |
|-----------|----------------|--------|
| Argument annotation | `def foo(data: Mesh2D):` | `Mesh2D` (the factory) is the **type descriptor** recognized by the engine. |
| Return annotation | `def foo(...) -> Mesh2D:` | Same ‚Äì the node must return `Mesh2D().dataclass()`. |
| Creating the concrete object inside a node | `obj = Mesh2D().dataclass()` | This call produces the actual container with mutable fields. |
| Passing the object to another node | `next_node(V_ext=wf.V_ext, ...)` | `wf.V_ext` already stores the concrete instance; the engine forwards it. |

### 2.3‚ÄØWhy use **input‚Äë** and **output‚Äëdataclasses**?  

* **Cleaner graphs** ‚Äì a single port carries a whole structured object instead of many scalar ports.  
* **Reduced wiring effort** ‚Äì only one connection per dataclass is needed.  
* **Self‚Äëdocumenting** ‚Äì the fields of the dataclass describe the data that flows through the workflow.  

### 2.4‚ÄØOptional: Making static type‚Äëcheckers happy  

```python
# Type alias (helps mypy, pyright, etc.)
Mesh2DType: TypeAlias = Mesh2D
GridSpecType: TypeAlias = GridSpec

# Or a Protocol if you only need the fields
class Mesh2DProtocol(Protocol):
    array: np.ndarray
    x: np.ndarray
    y: np.ndarray
```

These are **optional** and have no effect at runtime.  

### 2.5‚ÄØAllowed imports for custom containers  

`as_out_dataclass_node` and `as_inp_dataclass_node` are **explicitly permitted** because they enable structured data flow.  

---  

## üìà 3Ô∏è‚É£ Multi‚ÄëOutput & `.outputs` Rules (Hard‚ÄëBan)  

If a node returns **multiple** outputs, they must be accessed **only** via the `.outputs` attribute with **named labels**.

```python
@as_function_node
def MeshgridNode(x, y):
    X, Y = np.meshgrid(x, y, indexing="ij")
    return X, Y          # labels are "X" and "Y"
```

**Correct usage**

```python
wf.grid = MeshgridNode(x=xs, y=ys)
wf.plot = PlotDensity(
    X=wf.grid.outputs.X,
    Y=wf.grid.outputs.Y,
    rho=wf.rho,
)
```

**Forbidden**

* `wf.X = wf.grid.outputs.X` (direct assignment)  
* `wf.plot = PlotDensity(X=wf.grid.outputs[0], Y=wf.grid.outputs[1])` (numeric indexing)  

If you need a value repeatedly, create a **dedicated node** that returns that single output.  

---  

## üñãÔ∏è 4Ô∏è‚É£ Plotting Rule ‚Äì MathText‚ÄëSafe Labels  

* Use only **matplotlib‚Äëcompatible mathtext** unless the user explicitly requests full LaTeX (`mpl.rcParams['text.usetex'] = True`).  

Supported example  

```python
label = r"$\rho(\mathrm{r})$"          # ‚úÖ
title = r"$E_{\mathrm{kin}}$"          # ‚úÖ
```

Unsupported in default mathtext  

```python
r"$\rho(\mathbf{r})$"   # ‚ùå (fails without usetex)
```

---  

## üõ†Ô∏è 5Ô∏è‚É£ Workflow Construction Rules  

1. **All computation must happen inside function nodes** ‚Äì never inline in the workflow assembly.  
2. **Inputs at assembly time** may only be **basic literals** (`int`, `float`, `str`, `bool`, `Optional[...]`, `Literal[...]`) **or** outputs of other nodes.  
3. **Never assign `None` or placeholder arrays** to workflow attributes.  
4. **No external file reads/writes** unless a node explicitly does so (user‚Äërequested).  

---  

## üìö 6Ô∏è‚É£ Minimal Compliant Example (Shows Input‚Äë/Output‚ÄëDataclasses & `Optional[Literal]`)  

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from typing import Optional, Literal

from pyiron_workflow import (
    Workflow,
    as_function_node,
    as_out_dataclass_node,
    as_inp_dataclass_node,
)
from pyiron_workflow.data_fields import DataArray, EmptyArrayField

# ----------------------------------------------------------------------
# 1Ô∏è‚É£  Output dataclass ‚Äì travels through the workflow
# ----------------------------------------------------------------------
@as_out_dataclass_node
class Mesh2D:
    """Container for a 2‚ÄëD field and its grid vectors."""
    array: DataArray = EmptyArrayField
    x:     DataArray = EmptyArrayField
    y:     DataArray = EmptyArrayField

# ----------------------------------------------------------------------
# 2Ô∏è‚É£  Input dataclass ‚Äì gathers grid parameters from the user
# ----------------------------------------------------------------------
@as_inp_dataclass_node
class GridSpec:
    """Rectangular grid specification."""
    x_min: float = 0.0
    x_max: float = 2 * np.pi
    y_min: float = 0.0
    y_max: float = 2 * np.pi
    nx:    int   = 100
    ny:    int   = 100

# ----------------------------------------------------------------------
# 3Ô∏è‚É£  Nodes
# ----------------------------------------------------------------------
@as_function_node
def CreateExamplePotential(grid: GridSpec, amplitude: float = 1.0) -> Mesh2D:
    """Generate a sinusoidal external potential on the supplied grid."""
    x = np.linspace(grid.x_min, grid.x_max, grid.nx)
    y = np.linspace(grid.y_min, grid.y_max, grid.ny)
    X, Y = np.meshgrid(x, y, indexing="ij")

    pot = Mesh2D().dataclass()
    pot.array = amplitude * np.sin(X) * np.cos(Y)
    pot.x = X
    pot.y = Y
    return pot

@as_function_node("density")
def ComputeDensity(V_ext: Mesh2D, T: float = 300.0, rho_bulk: float = 0.01) -> Mesh2D:
    """Boltzmann‚Äëweighted density from an external potential."""
    kB_eV_per_K = 8.617333262e-5
    beta = 1.0 / (kB_eV_per_K * T)

    rho = Mesh2D().dataclass()
    rho.array = rho_bulk * np.exp(-beta * V_ext.array)
    rho.x = V_ext.x
    rho.y = V_ext.y
    return rho

# ----------------------------------------------------------------------
# 4Ô∏è‚É£  Plotting node ‚Äì expose selectable colormap and shading
# ----------------------------------------------------------------------
CmapChoice = Optional[Literal["viridis", "plasma", "inferno", "magma", "cividis"]]

@as_function_node
def PlotDensity(
    rho: Mesh2D,
    cmap: CmapChoice = "viridis",
    shading: Literal["auto", "nearest"] = "auto",
) -> Figure:
    """Plot the 2‚ÄëD density field."""
    fig, ax = plt.subplots()
    pcm = ax.pcolormesh(
        rho.x,
        rho.y,
        rho.array,
        shading=shading,
        cmap=cmap,
    )
    fig.colorbar(pcm, ax=ax, label=r"$\rho(\mathrm{r})$")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title("Density")
    return fig

# ----------------------------------------------------------------------
# 5Ô∏è‚É£  Assemble the workflow ‚Äì only literals + node outputs
# ----------------------------------------------------------------------
wf = Workflow("classical_dft_2d_density")

# 5.1  Provide grid definition (input‚Äëdataclass node)
wf.grid = GridSpec(
    x_min=0.0,
    x_max=2 * np.pi,
    y_min=0.0,
    y_max=2 * np.pi,
    nx=200,
    ny=200,
)

# 5.2  Create external potential using the grid object
wf.V_ext = CreateExamplePotential(grid=wf.grid, amplitude=0.5)

# 5.3  Compute Boltzmann density
wf.rho = ComputeDensity(V_ext=wf.V_ext, T=300.0, rho_bulk=0.01)

# 5.4  Plot ‚Äì user can change colormap or shading here
wf.fig = PlotDensity(
    rho=wf.rho,
    cmap="plasma",          # any of the allowed literals, or omit for default
    shading="auto",
)

# ----------------------------------------------------------------------
# 6Ô∏è‚É£  (Optional) Display the figure in a Jupyter notebook
# ----------------------------------------------------------------------
# from IPython.display import display
# display(wf.fig)
```

---  

## üìå Common Pitfalls (Recap)  

| Issue | ‚ùå Bad | ‚úÖ Good |
|-------|-------|--------|
| Using a call in a type hint | `def foo(p: Mesh2D().dataclass())` | `def foo(p: Mesh2D)` |
| Returning wrong type | `def foo(...) -> np.ndarray` but returns `Mesh2D` | Align annotation with return (`-> Mesh2D`) |
| Numeric indexing of multi‚Äëoutput | `wf.node.outputs[0]` | `wf.node.outputs.X` |
| Unsupported mathtext | `label=r"$\rho(\mathbf{r})$"` | `label=r"$\rho(\mathrm{r})$"` |
| External file read in workflow assembly | `wf.V = np.loadtxt("file.dat")` | `wf.V = LoadPotential(filename="file.dat")` (only if user asks) |
| Not exposing useful parameters | Fixed colormap inside `PlotDensity` | `cmap: Optional[Literal[...]] = "viridis"` |

